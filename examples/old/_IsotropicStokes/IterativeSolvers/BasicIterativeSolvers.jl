# Code generated by ChatGPT 

function preconditioned_minres(A, b, ApplyPC, Dinv, tol=1e-8, max_iter=nothing)
    # A: Symmetric matrix
    # b: Right-hand side vector
    # ApplyPC: Function to apply preconditioner (inverse of M)
    # tol: Convergence tolerance
    # max_iter: Maximum number of iterations (default to n if not specified)
    
    n = length(b)
    
    # Initial guess (zero vector)
    x = zeros(n)
    
    # Initial residual and preconditioned residual
    r0 = b - A * x
    z0 = ApplyPC(Dinv, r0)
    p = z0
    
    # Initialize residual and preconditioned residual
    r = r0
    z = z0
    norm_r0 = norm(r)
    
    if isnothing(max_iter)
        max_iter = n  # Default to the size of the matrix
    end
    
    # Iteration loop
    for k in 1:max_iter
        # Compute A * p
        Ap = A * p
        
        # Compute step size alpha
        alpha = dot(r, z) / dot(p, Ap)
        
        # Update the solution vector x
        x += alpha * p
        
        # Compute new residual
        r_new = r - alpha * Ap
        norm_r_new = norm(r_new)
        
        # Check for convergence
        if norm_r_new / norm_r0 < tol
            println("Converged in $k iterations.")
            return x
        end
        
        # Apply preconditioner to the new residual
        z_new = ApplyPC(Dinv, r_new)
        
        # Compute the beta value for the direction update
        beta = dot(r_new, z_new) / dot(r, z)
        
        # Update the direction p and residual r
        p = z_new + beta * p
        r = r_new
        z = z_new
    end
    
    println("Maximum iterations reached ($max_iter).")
    return x
end

# Preconditioner is the identity matrix (no preconditioning)
function ApplyPC(Dinv, x)
    return Dinv*x  # Identity preconditioner (no change)
end

# Function for applying the preconditioner M^{-1} to a vector
# Here, M_inv is a function that implements the preconditioner
function preconditioned_bicgstab(A, b, ApplyPC, Dinv, x0 = zeros(length(b)), tol = 1e-8, max_iter = 1000)
    # Initial residual
    r0 = b - A * x0
    z0 = ApplyPC(Dinv,r0)  # Apply preconditioner
    
    # Initialize variables
    x = x0
    r = r0
    z = z0
    p = z
    p_hat = z
    rho_old = 1.0
    alpha = 1.0
    omega = 1.0
    tol_b = norm(b) * tol
    
    for k = 1:max_iter
        rho = dot(r, z)
        
        if abs(rho) < eps()
            println("Breakdown: rho is too small.")
            return x
        end
        
        if k > 1
            beta = (rho / rho_old) * (alpha / omega)
            p = z + beta * (p - omega * p_hat)
        else
            p = z
        end
        
        # Apply A to p
        Ap = A * p
        p_hat = ApplyPC(Dinv, A' * p)  # Apply preconditioner to the transpose
        
        # Compute alpha
        alpha = rho / dot(r, p_hat)
        
        # Update x and r
        x = x + alpha * p
        r_new = r - alpha * Ap
        
        # Compute omega (stabilization factor)
        omega = dot(r_new, p_hat) / dot(Ap, p_hat)
        
        # Update residual
        r = r_new
        z = ApplyPC(Dinv,r)  # Precondition residual
        
        # Check convergence
        if norm(r) < tol_b
            println("Converged after $k iterations.")
            return x
        end
        
        rho_old = rho
    end
    
    println("Max iterations reached.")
    return x
end